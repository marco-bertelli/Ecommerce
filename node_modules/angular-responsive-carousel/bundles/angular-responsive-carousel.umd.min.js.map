{"version":3,"sources":["../../../projects/angular-responsive-carousel/src/lib/touches.ts","../../../projects/angular-responsive-carousel/src/lib/carousel.ts","../../../projects/angular-responsive-carousel/src/lib/carousel.component.ts","../../../projects/angular-responsive-carousel/src/lib/carousel.module.ts"],"names":["Touches","properties","_this","this","eventType","undefined","handlers","startX","startY","lastTap","doubleTapMinTimeout","tapMinTimeout","touchstartTime","i","isMousedown","touchListeners","touchstart","touchmove","touchend","mouseListeners","mousedown","mousemove","mouseup","wheel","otherListeners","resize","handleTouchstart","event","elementPosition","getElementPosition","Date","getTime","getTouchstartPosition","runHandler","handleTouchmove","touches","detectPan","detectPinch","detectLinearSwipe","swipeType","handleLinearSwipe","handleTouchend","detectDoubleTap","detectTap","length","handleMousedown","getMousedownPosition","handleMousemove","handleMouseup","handleWheel","handleResize","element","toggleEventListeners","prototype","destroy","action","listeners","listener","Object","assign","detectTouchScreen","handler","window","addEventListener","removeEventListener","document","getLinearSwipeType","eventName","response","currentTime","tapLength","clearTimeout","doubleTapTimeout","setTimeout","movementX","Math","abs","moveLeft","moveTop","getBoundingClientRect","clientX","left","clientY","top","index","prefixes","split","query","matchMedia","matches","mq","join","on","Carousel","initialPositionX","newContainerPositionIndex","preliminarySlideCounter","slideCounter","previousSlideCounter","isContentImages","isLazyLoad","isContainerLocked","alignCells","initialContainerPosition","isTouchstart","isSlideInProgress","getCarouselElementPosition","containerInitialPositionX","isMoveInProgress","handleHorizontalSwipe","moveX","distanceAbs","getDistanceAbs","direction","getDirection","moveContainer","detectSlide","handleSlide","alignContainer","cells","children","visibleWidth","parentElement","clientWidth","setContainerWidth","defineProperty","images","cellLength","visibleCellsCount","overflowCellsLimit","isImagesLessCellLimit","floor","margin","minSwipeDistance","transitionDuration","transitionTimingFunction","cellWidth","ceil","fullCellWidth","totalContainerCellsCount","positionX","getMovePositionX","transformPositionX","distance","getDistance","duration","getContainerPosition","setInitialContainerPosition","correction","getContainerPositionCorrection","isContainerPositionCorrection","position","loop","isSlideLengthLimited","quicklyPositionContainer","initialPosition","getNewContainerPosition","lineUpCells","containerWidth","getContainerWidth","style","width","totalImageWidth","getFile","cellIndex","imageIndex","getFileIndex","file","type","image","positionIndex","getPositionIndex","counter","lastCellIndex","value","transition","transform","next","prev","select","slideLength","getSlideLength","limitSlideLength","detectLastSlide","detectContainerUnlock","isFirstCell","newSlideCounter","isNextArrowDisabled","visibleCellsOverflowContainer","isPrevArrowDisabled","handleSlideEnd","transformSlideEnd","setSlideCounter","resetTransition","container","sign","cell","getCellPositionX","getCenterPositionIndex","autoplay","autoplayId","setInterval","autoplayInterval","stopAutoplay","clearInterval","CarouselComponent","elementRef","ref","minTimeout","_cellWidth","events","EventEmitter","height","pauseOnHover","dots","objectFit","counterSeparator","arrows","arrowsTheme","hostClassCarousel","preventDefault","carousel","isMoving","emit","handleTap","currentCellIndex","fileIndex","lapCounter","innerWidth","innerHeight","ua","navigator","userAgent","toLowerCase","indexOf","nativeElement","querySelector","_images","_isCounter","cellLimit","onWindowResize","landscapeMode","isLandscape","detectChanges","initCarousel","onMousemove","onMouseleave","ngOnInit","isNgContent","cellsElement","setDimensions","ngAfterViewInit","getCellLength","dotsArr","Array","fill","ngOnChanges","changes","ngOnDestroy","getCellWidth","videoProperties","hostStyleHeight","hostStyleWidth","handleTransitionendCellContainer","toggleVideo","video","noPlay","paused","play","isVideoPlaying","pause","getCurrentIndex","Component","args","selector","exportAs","template","ElementRef","ChangeDetectorRef","Input","Output","HostBinding","HostListener","NgModule","declarations","imports","CommonModule","exports","providers","bootstrap","entryComponents"],"mappings":"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","sourcesContent":["export interface Properties {\r\n    element: HTMLElement;\r\n    listeners?: 'auto' | 'mouse and touch';\r\n    resize?: boolean;\r\n}\r\n\r\nexport type EventType = undefined | 'touchend' | 'pan' | 'pinch' | 'horizontal-swipe' | 'vertical-swipe' | 'tap' | 'longtap';\r\nexport type TouchHandler = 'handleTouchstart' | 'handleTouchmove' | 'handleTouchend';\r\nexport type MouseHandler = 'handleMousedown' | 'handleMousemove' | 'handleMouseup';\r\n\r\nexport class Touches {\r\n    properties: Properties;\r\n    element: HTMLElement;\r\n    elementPosition: ClientRect;\r\n    eventType: EventType = undefined;\r\n    handlers: any = {};\r\n    startX = 0;\r\n    startY = 0;\r\n    lastTap = 0;\r\n    doubleTapTimeout: any;\r\n    doubleTapMinTimeout = 300;\r\n    tapMinTimeout = 200;\r\n    touchstartTime = 0;\r\n    i: number = 0;\r\n    isMousedown = false;\r\n\r\n    touchListeners: any = {\r\n        \"touchstart\": \"handleTouchstart\",\r\n        \"touchmove\": \"handleTouchmove\",\r\n        \"touchend\": \"handleTouchend\"\r\n    }\r\n    mouseListeners: any = {\r\n        \"mousedown\": \"handleMousedown\",\r\n        \"mousemove\": \"handleMousemove\",\r\n        \"mouseup\": \"handleMouseup\",\r\n        \"wheel\": \"handleWheel\"\r\n    }\r\n    otherListeners: any = {\r\n        \"resize\": \"handleResize\"\r\n    }\r\n\r\n    constructor(properties: Properties) {\r\n        this.properties = properties;\r\n        this.element = this.properties.element;\r\n        this.elementPosition = this.getElementPosition();\r\n\r\n        this.toggleEventListeners('addEventListener');\r\n    }\r\n\r\n    destroy() {\r\n        this.toggleEventListeners('removeEventListener');\r\n    }\r\n\r\n    toggleEventListeners(action: 'addEventListener' | 'removeEventListener') {\r\n        let listeners;\r\n\r\n        if (this.properties.listeners === 'mouse and touch') {\r\n            listeners = Object.assign(this.touchListeners, this.mouseListeners);\r\n        } else {\r\n            listeners = this.detectTouchScreen() ? this.touchListeners : this.mouseListeners;\r\n        }\r\n\r\n        if (this.properties.resize) {\r\n            listeners = Object.assign(listeners, this.otherListeners);\r\n        }\r\n\r\n        for (var listener in listeners) {\r\n            const handler: MouseHandler = listeners[listener];\r\n\r\n            // Window\r\n            if (listener === \"resize\") {\r\n                if (action === 'addEventListener') {\r\n                    window.addEventListener(listener, this[handler], false);\r\n                }\r\n                if (action === 'removeEventListener') {\r\n                    window.removeEventListener(listener, this[handler], false);\r\n                }\r\n            // Document\r\n            } else if (listener === 'mouseup' || listener === \"mousemove\") {\r\n                if (action === 'addEventListener') {\r\n                    document.addEventListener(listener, this[handler], false);\r\n                }\r\n                if (action === 'removeEventListener') {\r\n                    document.removeEventListener(listener, this[handler], false);\r\n                }\r\n            // Element\r\n            } else {\r\n                if (action === 'addEventListener') {\r\n                    this.element.addEventListener(listener, this[handler], false);\r\n                }\r\n                if (action === 'removeEventListener') {\r\n                    this.element.removeEventListener(listener, this[handler], false);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Listeners\r\n     */\r\n\r\n    /* Touchstart */\r\n\r\n    handleTouchstart = (event: any) => {\r\n        this.elementPosition = this.getElementPosition();\r\n        this.touchstartTime = new Date().getTime();\r\n\r\n        if (this.eventType === undefined) {\r\n            this.getTouchstartPosition(event);\r\n        }\r\n\r\n        this.runHandler(\"touchstart\", event);\r\n    }\r\n\r\n\r\n    /* Touchmove */\r\n\r\n    handleTouchmove = (event: any) => {\r\n        const touches = event.touches;\r\n\r\n        // Pan\r\n        if (this.detectPan(touches)) {\r\n            this.runHandler(\"pan\", event);\r\n        }\r\n\r\n        // Pinch\r\n        if (this.detectPinch(event)) {\r\n            this.runHandler(\"pinch\", event);\r\n        }\r\n\r\n        // Linear swipe\r\n        switch (this.detectLinearSwipe(event)) {\r\n            case \"horizontal-swipe\":\r\n                event.swipeType = \"horizontal-swipe\";\r\n                this.runHandler(\"horizontal-swipe\", event);\r\n                break;\r\n            case \"vertical-swipe\":\r\n                event.swipeType = \"vertical-swipe\";\r\n                this.runHandler(\"vertical-swipe\", event);\r\n                break;\r\n        }\r\n\r\n        // Linear swipe\r\n        if (this.detectLinearSwipe(event) ||\r\n            this.eventType === 'horizontal-swipe' ||\r\n            this.eventType === 'vertical-swipe') {\r\n\r\n            this.handleLinearSwipe(event);\r\n        }\r\n    }\r\n\r\n    handleLinearSwipe(event: any) {\r\n        //event.preventDefault();\r\n\r\n        this.i++;\r\n\r\n        if (this.i > 3) {\r\n            this.eventType = this.getLinearSwipeType(event);\r\n        }\r\n\r\n        if (this.eventType === 'horizontal-swipe') {\r\n            this.runHandler('horizontal-swipe', event);\r\n        }\r\n\r\n        if (this.eventType === 'vertical-swipe') {\r\n            this.runHandler('vertical-swipe', event);\r\n        }\r\n    }\r\n\r\n\r\n    /* Touchend */\r\n\r\n    handleTouchend = (event: any) => {\r\n        const touches = event.touches;\r\n\r\n        // Double Tap\r\n        if (this.detectDoubleTap()) {\r\n            this.runHandler(\"double-tap\", event);\r\n        }\r\n\r\n        // Tap\r\n        this.detectTap();\r\n\r\n        this.runHandler(\"touchend\", event);\r\n        this.eventType = 'touchend';\r\n\r\n        if (touches && touches.length === 0) {\r\n            this.eventType = undefined;\r\n            this.i = 0;\r\n        }\r\n    }\r\n\r\n\r\n    /* Mousedown */\r\n\r\n    handleMousedown = (event: any) => {\r\n        this.isMousedown = true;\r\n        this.elementPosition = this.getElementPosition();\r\n        this.touchstartTime = new Date().getTime();\r\n\r\n        if (this.eventType === undefined) {\r\n            this.getMousedownPosition(event);\r\n        }\r\n\r\n        this.runHandler(\"mousedown\", event);\r\n    }\r\n\r\n\r\n    /* Mousemove */\r\n\r\n    handleMousemove = (event: any) => {\r\n        //event.preventDefault();\r\n        \r\n        if (!this.isMousedown) {\r\n            return;\r\n        }\r\n\r\n        // Pan\r\n        this.runHandler(\"pan\", event);\r\n\r\n        // Linear swipe\r\n        switch (this.detectLinearSwipe(event)) {\r\n            case \"horizontal-swipe\":\r\n                event.swipeType = \"horizontal-swipe\";\r\n                this.runHandler(\"horizontal-swipe\", event);\r\n                break;\r\n            case \"vertical-swipe\":\r\n                event.swipeType = \"vertical-swipe\";\r\n                this.runHandler(\"vertical-swipe\", event);\r\n                break;\r\n        }\r\n\r\n        // Linear swipe\r\n        if (this.detectLinearSwipe(event) ||\r\n            this.eventType === 'horizontal-swipe' ||\r\n            this.eventType === 'vertical-swipe') {\r\n\r\n            this.handleLinearSwipe(event);\r\n        }\r\n    }\r\n\r\n\r\n    /* Mouseup */\r\n\r\n    handleMouseup = (event: any) => {\r\n\r\n        // Tap\r\n        this.detectTap();\r\n\r\n        this.isMousedown = false;\r\n        this.runHandler(\"mouseup\", event);\r\n        this.eventType = undefined;\r\n        this.i = 0;\r\n    }\r\n\r\n\r\n    /* Wheel */\r\n\r\n    handleWheel = (event: any) => {\r\n        this.runHandler(\"wheel\", event);\r\n    }\r\n\r\n    /* Resize */\r\n\r\n    handleResize = (event: any) => {\r\n        this.runHandler(\"resize\", event);\r\n    }\r\n\r\n    runHandler(eventName: any, response: any) {\r\n        if (this.handlers[eventName]) {\r\n            this.handlers[eventName](response);\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n     * Detection\r\n     */\r\n\r\n    detectPan(touches: any) {\r\n        return touches.length === 1 && !this.eventType || this.eventType === 'pan';\r\n    }\r\n\r\n    detectDoubleTap() {\r\n        if (this.eventType != undefined) {\r\n            return;\r\n        }\r\n\r\n        const currentTime = new Date().getTime();\r\n        const tapLength = currentTime - this.lastTap;\r\n\r\n        clearTimeout(this.doubleTapTimeout);\r\n\r\n        if (tapLength < this.doubleTapMinTimeout && tapLength > 0) {\r\n            return true;\r\n        } else {\r\n            this.doubleTapTimeout = setTimeout(() => {\r\n                clearTimeout(this.doubleTapTimeout);\r\n            }, this.doubleTapMinTimeout);\r\n        }\r\n        this.lastTap = currentTime;\r\n    }\r\n\r\n    detectTap(): void {\r\n        if (this.eventType != undefined) {\r\n            return;\r\n        }\r\n\r\n        const currentTime = new Date().getTime();\r\n        const tapLength = currentTime - this.touchstartTime;\r\n\r\n        if (tapLength > 0) {\r\n            if (tapLength < this.tapMinTimeout) {\r\n                this.runHandler(\"tap\", event);\r\n            } else {\r\n                this.runHandler(\"longtap\", event);\r\n            }\r\n        }\r\n    }\r\n\r\n    detectPinch(event: any) {\r\n        const touches = event.touches;\r\n        return (touches.length === 2 && this.eventType === undefined) || this.eventType === 'pinch';\r\n    }\r\n\r\n    detectLinearSwipe(event: any) {\r\n        const touches = event.touches;\r\n\r\n        if (touches) {\r\n            if (touches.length === 1 && !this.eventType || this.eventType === 'horizontal-swipe' || this.eventType === 'vertical-swipe') {\r\n                return this.getLinearSwipeType(event);\r\n            }\r\n        } else {\r\n            if (!this.eventType || this.eventType === 'horizontal-swipe' || this.eventType === 'vertical-swipe') {\r\n                return this.getLinearSwipeType(event);\r\n            }\r\n        }\r\n    }\r\n\r\n    getLinearSwipeType(event: any) {\r\n        if (this.eventType !== 'horizontal-swipe' && this.eventType !== 'vertical-swipe') {\r\n            const movementX = Math.abs(this.moveLeft(0, event) - this.startX);\r\n            const movementY = Math.abs(this.moveTop(0, event) - this.startY);\r\n\r\n            if ((movementY * 3) > movementX) {\r\n                return 'vertical-swipe';\r\n            } else {\r\n                return 'horizontal-swipe';\r\n            }\r\n        } else {\r\n            return this.eventType;\r\n        }\r\n    }\r\n\r\n    getElementPosition() {\r\n        return this.element.getBoundingClientRect();\r\n    }\r\n\r\n    getTouchstartPosition(event: any) {\r\n        this.startX = event.touches[0].clientX - this.elementPosition.left;\r\n        this.startY = event.touches[0].clientY - this.elementPosition.top;\r\n    }\r\n\r\n    getMousedownPosition(event: any) {\r\n        this.startX = event.clientX - this.elementPosition.left;\r\n        this.startY = event.clientY - this.elementPosition.top;\r\n    }\r\n\r\n    moveLeft(index: any, event: any) {\r\n        const touches = event.touches;\r\n\r\n        if (touches) {\r\n            return touches[index].clientX - this.elementPosition.left;\r\n        } else {\r\n            return event.clientX - this.elementPosition.left;\r\n        }\r\n    }\r\n\r\n    moveTop(index: any, event: any) {\r\n        const touches = event.touches;\r\n\r\n        if (touches) {\r\n            return touches[index].clientY - this.elementPosition.top;\r\n        } else {\r\n            return event.clientY - this.elementPosition.top;\r\n        }\r\n    }\r\n\r\n    detectTouchScreen() {\r\n        var prefixes = ' -webkit- -moz- -o- -ms- '.split(' ');\r\n        var mq = function(query: any) {\r\n            return window.matchMedia(query).matches;\r\n        }\r\n\r\n        if (('ontouchstart' in window)) {\r\n            return true;\r\n        }\r\n\r\n        // include the 'heartz' as a way to have a non matching MQ to help terminate the join\r\n        // https://git.io/vznFH\r\n        var query = ['(', prefixes.join('touch-enabled),('), 'heartz', ')'].join('');\r\n        return mq(query);\r\n    }\r\n\r\n\r\n    /* Public properties and methods */\r\n    on(event: EventType, handler: Function) {\r\n        if (event) {\r\n            this.handlers[event] = handler;\r\n        }\r\n    }\r\n}","export interface Properties {\r\n    element: HTMLElement;\r\n    container: HTMLElement;\r\n    images: any;\r\n    cellWidth: number;\r\n    loop: boolean;\r\n    autoplayInterval: number;\r\n    overflowCellsLimit: number;\r\n    visibleWidth: number;\r\n    margin: number;\r\n    minSwipeDistance: number;\r\n    transitionDuration: number;\r\n    transitionTimingFunction: 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear';\r\n    videoProperties: any;\r\n}\r\n\r\nexport class Carousel {\r\n    properties: Properties;\r\n    element: HTMLElement;\r\n    startX: number;\r\n    moveX: number;\r\n    direction: 'left' | 'right';\r\n    slideLength: number;\r\n    distanceAbs: number;\r\n    initialPositionX: number = 0;\r\n    cells: HTMLCollection;\r\n\r\n    newContainerPositionIndex: number = 0; // The index of the new position relative to the active index, for example -1 or +1\r\n    preliminarySlideCounter: number = 0;\r\n    slideCounter: number = 0; // Scrolling Index (counter)\r\n    previousSlideCounter: number = 0;\r\n\r\n    isSlideInProgress: boolean;\r\n    isMoveInProgress: boolean;\r\n    isTransitionInProgress: boolean;\r\n    isTouchstart: boolean;\r\n    isSlideLengthLimited: boolean;\r\n    isContainerPositionCorrection: boolean;\r\n\r\n    containerInitialPositionX: number;\r\n    isContentImages: boolean = true;\r\n    visibleWidth: number;\r\n    isLazyLoad: boolean = true;\r\n    isContainerLocked: boolean = true;\r\n    alignCells: \"left\" | \"center\" = \"left\";\r\n    initialContainerPosition: number = 0;\r\n    autoplayId: any;\r\n\r\n    get cellLength() {\r\n        if (this.images) {\r\n            return this.images.length;\r\n        } else {\r\n            return this.cells.length;\r\n        }\r\n    }\r\n\r\n    get totalContainerCellsCount() {\r\n        if (this.images) {\r\n            let cellLength = this.visibleCellsCount + this.overflowCellsLimit * 2;\r\n            if (cellLength > this.images.length) {\r\n                cellLength = this.images.length;\r\n            }\r\n            return cellLength;\r\n        } else {\r\n            return this.cellLength;\r\n        }\r\n    }\r\n\r\n    get isFirstCell() {\r\n        return this.slideCounter === 0;\r\n    }\r\n\r\n    get lastCellIndex() {\r\n        return this.images.length ? (this.images.length - 1) : (this.cells.length - 1);\r\n    }\r\n\r\n    get overflowCellsLimit() {\r\n        if (this.images && this.isImagesLessCellLimit) {\r\n            return Math.floor((this.images.length - this.visibleCellsCount) / 2);\r\n        } else {\r\n            return this.properties.overflowCellsLimit;\r\n        }\r\n    }\r\n\r\n    get isImagesLessCellLimit() {\r\n        return this.properties.overflowCellsLimit * 2 + this.visibleCellsCount > this.images.length;\r\n    }\r\n\r\n    get cellLimit() {\r\n        return this.visibleCellsCount + this.overflowCellsLimit * 2;\r\n    }\r\n\r\n    get images() {\r\n        return this.properties.images;\r\n    }\r\n\r\n    get margin() {\r\n        return this.properties.margin;\r\n    }\r\n\r\n    get minSwipeDistance() {\r\n        return this.properties.minSwipeDistance;\r\n    }\r\n\r\n    get transitionDuration() {\r\n        return this.properties.transitionDuration;\r\n    }\r\n\r\n    get transitionTimingFunction() {\r\n        return this.properties.transitionTimingFunction;\r\n    }\r\n\r\n    get fullCellWidth() {\r\n        return this.properties.cellWidth + this.margin;\r\n    }\r\n\r\n    get visibleCellsCount() {\r\n        return Math.ceil(this.visibleWidth / this.fullCellWidth);\r\n    }\r\n\r\n    get lapCounter() {\r\n        return Math.floor(this.slideCounter / this.totalContainerCellsCount);\r\n    }\r\n\r\n    get visibleCellsOverflowContainer() {\r\n        return (this.visibleCellsCount * this.fullCellWidth -this.margin) > this.visibleWidth;\r\n    }\r\n\r\n    constructor(properties: Properties) {\r\n        this.element = properties.element;\r\n        this.properties = properties;\r\n        this.cells = this.element.children;\r\n        this.visibleWidth = this.properties.visibleWidth || this.element.parentElement.clientWidth;\r\n\r\n        this.setContainerWidth();\r\n        this.alignContainer(0);\r\n    }\r\n\r\n    handleTouchstart = (event: any) => {\r\n        this.isTouchstart = true;\r\n\r\n        if (this.isSlideInProgress) {\r\n            return;\r\n        }\r\n\r\n        const touches = event.touches;\r\n        if (touches) {\r\n            this.startX = touches[0].clientX - this.getCarouselElementPosition()['left'];\r\n        } else {\r\n            this.startX = event.clientX - this.getCarouselElementPosition()['left'];\r\n        }\r\n        this.containerInitialPositionX = this.getElementPosition()['left'] - this.getCarouselElementPosition()['left'];\r\n        this.isMoveInProgress = true;\r\n    }\r\n\r\n    handleHorizontalSwipe = (event: any) => {\r\n        if (this.isSlideInProgress) {\r\n            return;\r\n        }\r\n\r\n        const touches = event.touches;\r\n        if (touches) {\r\n            this.moveX = touches[0].clientX - this.getCarouselElementPosition()['left'];\r\n        } else {\r\n            this.moveX = event.clientX - this.getCarouselElementPosition()['left'];\r\n        }\r\n        this.distanceAbs = this.getDistanceAbs();\r\n        this.direction = this.getDirection();\r\n\r\n        this.moveContainer();\r\n    }\r\n\r\n    handleTouchend = (event: any) => {\r\n        if (this.isSlideInProgress || !this.isTouchstart) {\r\n            this.isTouchstart = false;\r\n            return;\r\n        }\r\n\r\n        this.isMoveInProgress = false;\r\n\r\n        if (this.detectSlide()) {\r\n            this.handleSlide();\r\n        } else {\r\n            this.newContainerPositionIndex = 0;\r\n            this.alignContainer();\r\n        }\r\n\r\n        this.startX = this.moveX = this.distanceAbs = undefined;\r\n        this.isTouchstart = false;\r\n    }\r\n\r\n    /* Move */\r\n    moveContainer() {\r\n        let positionX = this.getMovePositionX();\r\n        this.transformPositionX(positionX, 0);\r\n    }\r\n\r\n    getMovePositionX() {\r\n        const distance = this.getDistance();\r\n        return this.containerInitialPositionX - distance;\r\n    }\r\n\r\n    /* Align */\r\n    alignContainer(duration: number = this.transitionDuration) {\r\n        let positionX = this.getContainerPosition();\r\n        this.transformPositionX(positionX, duration);\r\n        this.setInitialContainerPosition(positionX);\r\n    }\r\n\r\n    getContainerPosition() {\r\n        let correction = this.getContainerPositionCorrection();\r\n\r\n        this.isContainerPositionCorrection = correction != 0;\r\n        return (this.initialContainerPosition + this.newContainerPositionIndex * this.fullCellWidth) + correction;\r\n    }\r\n\r\n    setInitialContainerPosition(position) {\r\n        let correction = this.getContainerPositionCorrection();\r\n        this.initialContainerPosition = position - correction;\r\n    }\r\n\r\n    getContainerPositionCorrection() {\r\n        let correction = 0;\r\n\r\n        if (this.properties.loop) {\r\n            return 0;\r\n        }\r\n\r\n        if ((this.cellLength - this.preliminarySlideCounter) < this.visibleCellsCount || this.isSlideLengthLimited) {\r\n            if (this.visibleWidth < this.totalContainerCellsCount * this.fullCellWidth) {\r\n                correction = - (this.visibleCellsCount * this.fullCellWidth - this.visibleWidth - this.margin);\r\n            }\r\n\r\n            if (correction >= - this.margin) {\r\n                correction = 0;\r\n            }\r\n        }\r\n\r\n        return correction;\r\n    }\r\n\r\n    /* Quickly center */\r\n    quicklyPositionContainer() {\r\n        let correction = this.getContainerPositionCorrection();\r\n        const initialPosition = this.getNewContainerPosition() + correction;\r\n        this.transformPositionX(initialPosition, 0);\r\n        this.setInitialContainerPosition(initialPosition);\r\n    }\r\n\r\n    getNewContainerPosition() {\r\n        if (this.slideCounter > this.overflowCellsLimit) {\r\n            if (this.alignCells === \"left\") {\r\n                this.lineUpCells();\r\n                return -(this.overflowCellsLimit * this.fullCellWidth);\r\n            }\r\n        }\r\n\r\n        if (this.slideCounter <= this.overflowCellsLimit) {\r\n            if (this.previousSlideCounter > this.overflowCellsLimit) {\r\n                this.lineUpCells();\r\n            }\r\n            return -(this.slideCounter * this.fullCellWidth);\r\n        }\r\n    }\r\n\r\n    setContainerWidth() {\r\n        const containerWidth = this.getContainerWidth();\r\n        this.element.style.width = containerWidth + \"px\";\r\n    }\r\n\r\n    getContainerWidth() {\r\n        let containerWidth = this.totalContainerCellsCount * this.fullCellWidth;\r\n        let totalImageWidth = this.cellLength * this.fullCellWidth;\r\n\r\n        if (totalImageWidth < containerWidth) {\r\n            containerWidth = totalImageWidth;\r\n        }\r\n\r\n        return containerWidth;\r\n    }\r\n\r\n    getFile(cellIndex) {\r\n        let imageIndex = this.getFileIndex(cellIndex); \r\n        let file = this.images[imageIndex];\r\n\r\n        if (file && !file.type) {\r\n            file.type = 'image';\r\n        }\r\n\r\n        return {\r\n            image: this.images[imageIndex],\r\n            imageIndex\r\n        };\r\n    }\r\n\r\n    getFileIndex(cellIndex: number) {\r\n        const positionIndex = this.getPositionIndex(cellIndex);\r\n        const numberLeftCells = (this.totalContainerCellsCount - 1) / 2;\r\n        let imageIndex;\r\n        let counter = this.slideCounter;\r\n\r\n        if (!this.isContainerLocked) {\r\n            if (counter <= this.overflowCellsLimit) {\r\n                return cellIndex;\r\n            } else {\r\n                let cellLimitOverflow = counter - this.overflowCellsLimit;\r\n                imageIndex = positionIndex + cellLimitOverflow;\r\n\r\n                if (this.images && this.properties.loop) {\r\n                    imageIndex = imageIndex % this.images.length;\r\n                }\r\n\r\n                return imageIndex;\r\n            }\r\n        }\r\n\r\n        if (this.alignCells === \"left\") {\r\n            if (counter > this.overflowCellsLimit) {\r\n                let cellLimitOverflow = counter - this.overflowCellsLimit;\r\n                imageIndex = positionIndex + cellLimitOverflow;\r\n            } else {\r\n                imageIndex = cellIndex;\r\n            }\r\n        }\r\n\r\n        if (imageIndex > this.lastCellIndex && !this.properties.loop) {\r\n            return false;\r\n        }\r\n\r\n        return imageIndex;\r\n    }\r\n\r\n    transformPositionX(value, duration = this.transitionDuration) {\r\n        this.element.style.transition = 'transform ' + duration + 'ms ' + this.transitionTimingFunction;\r\n        this.element.style.transform = 'translateX(' + value + 'px)';\r\n    }\r\n\r\n    detectSlide() {\r\n        return this.distanceAbs >= this.minSwipeDistance;\r\n    }\r\n\r\n    next() {\r\n        if (this.isSlideInProgress) {\r\n            return;\r\n        }\r\n\r\n        this.direction = 'left';\r\n        this.handleSlide(1);\r\n    }\r\n\r\n    prev() {\r\n        if (this.isSlideInProgress) {\r\n            return;\r\n        }\r\n\r\n        this.direction = 'right';\r\n        this.handleSlide(1);\r\n    }\r\n\r\n    select(index: number) {\r\n        this.slideCounter = index;\r\n        this.quicklyPositionContainer();\r\n    }\r\n\r\n    handleSlide(slideLength: number = undefined): void {\r\n        this.slideLength = this.getSlideLength();\r\n        this.slideLength = slideLength ? slideLength : this.limitSlideLength(this.slideLength);\r\n\r\n        if (this.direction === 'left' && !this.isSlideInProgress) {\r\n            this.preliminarySlideCounter = this.slideCounter + this.slideLength;\r\n\r\n            if (!this.detectLastSlide(this.slideCounter + this.slideLength)) {\r\n                this.newContainerPositionIndex = this.newContainerPositionIndex - this.slideLength;\r\n                this.isSlideInProgress = true;\r\n\r\n                if (this.isLazyLoad) {\r\n                    this.isContainerLocked = this.preliminarySlideCounter > this.overflowCellsLimit;\r\n\r\n                    if (this.detectContainerUnlock()) {\r\n                        this.isContainerLocked = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.direction === 'right' && !this.isSlideInProgress) {\r\n            if (this.slideCounter - this.slideLength < 0) {\r\n                this.slideLength = this.slideCounter;\r\n            }\r\n\r\n            this.preliminarySlideCounter = this.slideCounter - this.slideLength;\r\n\r\n            if (!this.isFirstCell) {\r\n                this.newContainerPositionIndex = this.newContainerPositionIndex + this.slideLength;\r\n                this.isSlideInProgress = true;\r\n\r\n                if (this.isLazyLoad) {\r\n                    if (this.preliminarySlideCounter > this.overflowCellsLimit) {\r\n                        this.isContainerLocked = true;\r\n                    } else {\r\n                        this.isContainerLocked = false;\r\n                    }\r\n\r\n                    if (this.detectContainerUnlock()) {\r\n                        this.isContainerLocked = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.alignContainer();\r\n    }\r\n\r\n    getSlideLength() {\r\n        let correction = this.getContainerPositionCorrection();\r\n        let length = Math.floor((this.distanceAbs + correction) / this.fullCellWidth);\r\n\r\n        if (this.distanceAbs % this.fullCellWidth >= this.minSwipeDistance) {\r\n            length++;\r\n        }\r\n        return length;\r\n    }\r\n\r\n    limitSlideLength(slideLength: number) {\r\n        if (slideLength > 1) {\r\n\r\n            for (var i = 0; i < slideLength; i++) {\r\n                let newSlideCounter = this.slideCounter + (slideLength - i);\r\n\r\n                if (!this.detectLastSlide(newSlideCounter)) {\r\n                    slideLength = slideLength - i;\r\n                    this.isSlideLengthLimited = i > 0;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return slideLength;\r\n    }\r\n\r\n    detectLastSlide(slideCounter: number) {\r\n        if (this.properties.loop) {\r\n            return false;\r\n        } else {\r\n            return (this.cellLength - slideCounter) < this.visibleCellsCount;\r\n        }\r\n    }\r\n\r\n    isNextArrowDisabled() {\r\n        if (this.visibleCellsOverflowContainer) {\r\n            return this.detectLastSlide(this.slideCounter + 1) && this.isContainerPositionCorrection;\r\n        } else {\r\n            return this.detectLastSlide(this.slideCounter + 1);\r\n        }\r\n    }\r\n\r\n    isPrevArrowDisabled() {\r\n        return this.slideCounter === 0;\r\n    }\r\n\r\n    detectContainerUnlock() {\r\n        return (this.cellLength - this.preliminarySlideCounter) < (this.visibleCellsCount + this.overflowCellsLimit);\r\n    }\r\n\r\n    handleSlideEnd() {\r\n        if (this.isSlideInProgress) {\r\n            this.transformSlideEnd();\r\n\r\n            this.isSlideInProgress = false;\r\n            this.newContainerPositionIndex = 0;\r\n            this.isSlideLengthLimited = undefined;\r\n        }\r\n    }\r\n\r\n    transformSlideEnd() {\r\n        if (this.isLazyLoad) {\r\n            this.setSlideCounter();\r\n            if (this.images || !this.images && this.properties.loop) {\r\n                this.quicklyPositionContainer();\r\n            }\r\n        }\r\n\r\n        this.previousSlideCounter = this.slideCounter;\r\n    }\r\n\r\n    setSlideCounter() {\r\n        if (this.direction === 'left') {\r\n            this.slideCounter = this.slideCounter + this.slideLength;\r\n        }\r\n\r\n        if (this.direction === 'right') {\r\n            this.slideCounter = this.slideCounter - this.slideLength;\r\n        }\r\n\r\n        this.direction = undefined;\r\n        this.slideLength = 0;\r\n    }\r\n\r\n    resetTransition() {\r\n        this.element.style.transition = '';\r\n    }\r\n\r\n    getElementPosition() {\r\n        return this.element.getBoundingClientRect();\r\n    }\r\n\r\n    getCarouselElementPosition() {\r\n        return this.properties.container.getBoundingClientRect();\r\n    }\r\n\r\n    getDistance() {\r\n        return this.startX - this.moveX;\r\n    }\r\n\r\n    getDistanceAbs() {\r\n        return Math.abs(this.startX - this.moveX);\r\n    }\r\n\r\n    getDirection() {\r\n        const direction = Math.sign(this.startX - this.moveX);\r\n\r\n        if (direction === -1) {\r\n            return 'right';\r\n        }\r\n        if (direction === 1) {\r\n            return 'left';\r\n        }\r\n    }\r\n\r\n    lineUpCells() {\r\n        const cells = this.element.children;\r\n\r\n        for (var i = 0; i < cells.length; i++) {\r\n            let cell = cells[i];\r\n            let positionX = this.getCellPositionX(i);\r\n            (cell as HTMLElement).style.transform = 'translateX(' + positionX + 'px)';\r\n\r\n            // notice\r\n            (cell as HTMLElement).style.width = this.properties.cellWidth+'px';\r\n        };\r\n    }\r\n\r\n    getCellPositionX(index) {\r\n        let positionIndex = this.getPositionIndex(index);\r\n        return positionIndex * this.fullCellWidth;\r\n    }\r\n\r\n    getPositionIndex(cellIndex) {\r\n        let counter = this.slideCounter;\r\n        let cellLength = this.totalContainerCellsCount;\r\n        let slideCounter = counter - this.overflowCellsLimit;\r\n        let positionIndex;\r\n\r\n        if (slideCounter > cellLength) {\r\n            slideCounter = slideCounter % cellLength;\r\n        }\r\n\r\n        if (slideCounter < 0) {\r\n            return cellIndex;\r\n        } else {\r\n            positionIndex = cellIndex - slideCounter;\r\n            if (positionIndex < 0) {\r\n                positionIndex = cellLength + positionIndex;\r\n            }\r\n        }\r\n\r\n        return positionIndex;\r\n    }\r\n\r\n    getCenterPositionIndex() {\r\n        return (this.totalContainerCellsCount - 1) / 2;\r\n    }\r\n\r\n    autoplay() {\r\n        this.autoplayId = setInterval(() => {\r\n            this.next(); \r\n        }, this.properties.autoplayInterval);\r\n    }\r\n\r\n    stopAutoplay() {\r\n        if (this.autoplayId) {\r\n            clearInterval(this.autoplayId);\r\n        }\r\n    }\r\n\r\n    destroy() {\r\n        this.stopAutoplay();\r\n    }\r\n}","import {ChangeDetectorRef, Component, ElementRef, ViewChild, EventEmitter, HostBinding, HostListener, Input, Output, OnDestroy, SimpleChanges} from '@angular/core';\n\nimport {Images} from './interfaces';\nimport {Touches} from './touches';\nimport {Carousel} from './carousel';\n\n\n@Component({\n\tselector: 'carousel, [carousel]',\n    exportAs: 'carousel',\n\ttemplateUrl: './carousel.component.html',\n    styleUrls: ['./carousel.component.sass']\n})\n\nexport class CarouselComponent implements OnDestroy {\n\n    get isContainerLocked() {\n        return this.carousel.isContainerLocked;\n    }\n    get slideCounter() {\n        return this.carousel.slideCounter;\n    }\n    get previousSlideCounter() {\n        return this.carousel.previousSlideCounter;\n    }\n    get lapCounter() {\n        return this.carousel.lapCounter;\n    }\n\n    lineUpCells() {\n        this.carousel.lineUpCells();\n    }\n\n    quicklyPositionContainer() {\n        this.carousel.quicklyPositionContainer();\n    }\n    \n    _id: string;\n    _images: Images;\n    touches: any;\n    carousel: any;\n    landscapeMode: any;\n    minTimeout = 30;\n    isVideoPlaying: boolean;\n    _isCounter: boolean;\n    _width: number;\n    _cellWidth: number | '100%' = 200;\n    isMoving: boolean;\n    isNgContent: boolean;\n    cellLength: number;\n    dotsArr:any;\n\n    get isLandscape(){\n        return window.innerWidth > window.innerHeight;\n    }\n\n    get isSafari(): any {\n        const ua = navigator.userAgent.toLowerCase();\n        if (ua.indexOf('safari') !== -1) {\n            return !(ua.indexOf('chrome') > -1);\n        }\n    }\n\n    get counter() {\n        let counter;\n\n        if (this.loop) {\n            counter = this.slideCounter % this.cellLength;\n        } else {\n            counter = this.slideCounter;\n        }\n\n        return counter + 1 + this.counterSeparator + this.cellLength;\n    }\n\n    get cellsElement() {\n        return this.elementRef.nativeElement.querySelector('.carousel-cells');\n    }\n\n    @Input()\n    set images(images: Images & any) {\n        this._images = images;\n    }\n    get images(){\n        return this._images;\n    }\n\n    @Output() events: EventEmitter<any> = new EventEmitter<any>();\n\n    @Input() height: number = 200;\n    @Input() width: number;\n    @Input() loop: boolean = false;\n    @Input() autoplay: boolean = false;\n    @Input() autoplayInterval: number = 5000;\n    @Input() pauseOnHover: boolean = true;\n    @Input() dots: boolean = false;\n    @Input() borderRadius: number;\n    @Input() margin: number = 10;\n    @Input() objectFit: 'contain' | 'cover' | 'none' = 'cover';\n    @Input() minSwipeDistance: number = 50;\n    @Input() transitionDuration: number = 200;\n    @Input() transitionTimingFunction: 'ease' | 'ease-in' | 'ease-out' | 'ease-in-out' | 'linear' = 'ease';\n    @Input() videoProperties: any;\n    @Input() counterSeparator: string = \" / \";\n    @Input() overflowCellsLimit: number = 3;\n    @Input() listeners: 'auto' | 'mouse and touch' = 'mouse and touch';\n\n    @Input('cellWidth') set cellWidth(value: number | '100%') {\n        if (value){\n            this._cellWidth = value;\n        }\n    }\n\n    @Input('counter') set isCounter(value: boolean) {\n        if (value){\n            this._isCounter = value;\n        }\n    }\n    get isCounter() {\n        return this._isCounter && this.cellLength > 1;\n    }\n\n    get activeDotIndex() {\n        return this.slideCounter % this.cellLength;\n    }\n\n    @Input() arrows: boolean = true;\n    @Input() arrowsOutside: boolean;\n    @Input() arrowsTheme: 'light' | 'dark' = 'light';\n\n    get cellLimit() {\n        if (this.carousel) {\n            return this.carousel.cellLimit;\n        }\n    }\n\n    @HostBinding('class.carousel') hostClassCarousel: boolean = true;\n    @HostBinding('style.height') hostStyleHeight: string;\n    @HostBinding('style.width') hostStyleWidth: string;\n\n    @HostListener('window:resize', ['$event'])\n    onWindowResize(event: any) {\n        this.landscapeMode = this.isLandscape;\n        this.ref.detectChanges();\n\n        this.initCarousel();\n        this.carousel.lineUpCells();\n    }\n\n    @HostListener('mousemove', ['$event'])\n    onMousemove(event: MouseEvent) {\n        if (this.autoplay && this.pauseOnHover) {\n            this.carousel.stopAutoplay();\n        }\n    }\n\n    @HostListener('mouseleave', ['$event'])\n    onMouseleave(event: MouseEvent) {\n        if (this.autoplay && this.pauseOnHover) {\n            this.carousel.autoplay();\n        }\n    }\n\n    constructor(\n        private elementRef: ElementRef, \n        private ref: ChangeDetectorRef){\n    }\n\n    ngOnInit(){\n        this.isNgContent = this.cellsElement.children.length > 0;\n\n        this.touches = new Touches({\n            element: this.cellsElement,\n            listeners: this.listeners\n        });\n\n        this.touches.on('touchstart', this.handleTouchstart);\n        this.touches.on('horizontal-swipe', this.handleHorizontalSwipe);\n        this.touches.on('touchend', this.handleTouchend);\n        this.touches.on('mousedown', this.handleTouchstart);\n        this.touches.on('mouseup', this.handleTouchend);\n        this.touches.on('tap', this.handleTap);\n\n        this.initCarousel();\n        this.setDimensions();\n\n        if (this.autoplay) {\n            this.carousel.autoplay();\n        }\n    }\n\n    ngAfterViewInit() {\n        this.cellLength = this.getCellLength();\n        this.dotsArr = Array(this.cellLength).fill(1);\n        this.ref.detectChanges();\n        this.carousel.lineUpCells();\n    }\n\n    ngOnChanges(changes: SimpleChanges) {\n        if (changes.width || changes.height) {\n            this.setDimensions();\n            this.initCarousel();\n            this.carousel.lineUpCells();\n        }\n    }\n\n    ngOnDestroy() {\n        this.touches.destroy();\n        this.carousel.destroy()\n    }\n\n    initCarousel() {\n        this.carousel = new Carousel({\n            element: this.elementRef.nativeElement.querySelector('.carousel-cells'),\n            container: this.elementRef.nativeElement,\n            images: this.images,\n            cellWidth: this.getCellWidth(),\n            loop: this.loop,\n            autoplayInterval: this.autoplayInterval,\n            overflowCellsLimit: this.overflowCellsLimit,\n            visibleWidth: this.width,\n            margin: this.margin,\n            minSwipeDistance: this.minSwipeDistance,\n            transitionDuration: this.transitionDuration,\n            transitionTimingFunction: this.transitionTimingFunction,\n            videoProperties: this.videoProperties\n        });\n    }\n\n    setDimensions() {\n        this.hostStyleHeight = this.height + 'px';\n        this.hostStyleWidth = this.width + 'px';\n    }\n\n    getFile(index) {\n        return this.carousel.getFile(index);\n    }\n\n    /* Touchstart */\n    handleTouchstart = (event: any) => {\n        event.preventDefault();\n        this.carousel.handleTouchstart(event);\n        this.isMoving = true;\n        this.events.emit({\n            type: 'touchstart',\n            event\n        });\n    }\n\n    /* Touchmove */\n    handleHorizontalSwipe = (event: any) => {\n        event.preventDefault();\n        this.carousel.handleHorizontalSwipe(event);\n        this.events.emit({\n            type: 'swipe',\n            event\n        });\n    }\n\n    /* Touchend */\n    handleTouchend = (event: any) => {\n        const touches = event.touches;\n        this.carousel.handleTouchend(event);\n        this.isMoving = false;\n        this.events.emit({\n            type: 'touchend',\n            event\n        });\n    }\n\n    /* Tap */\n    handleTap = (event: any) => {\n        const i = this.carousel.slideCounter;\n        const cellIndex = this.carousel.currentCellIndex;\n        const fileIndex = this.carousel.getFileIndex(i);\n        const file = this.carousel.getFile(cellIndex);\n\n        this.events.emit({\n            type: 'click',\n            file: file,\n            index: fileIndex\n        });\n    }\n\n    handleTransitionendCellContainer(event) {\n        this.carousel.handleSlideEnd();\n    }\n\n    toggleVideo(video) {\n        event.preventDefault();\n        if (this.videoProperties.noPlay) {\n            return;\n        }\n\n        if (video.paused) {\n            video.play();\n            this.isVideoPlaying = true;\n        } else {\n            video.pause();\n            this.isVideoPlaying = false;\n        }\n\n        this.ref.detectChanges();\n    }\n\n    getCurrentIndex() {\n        return this.carousel.slideCounter;\n    }\n\n    getCellWidth(): number {\n        if (this._cellWidth === '100%') {\n            return this.elementRef.nativeElement.clientWidth;\n        } else {\n            return this._cellWidth;\n        }\n    }\n\n    next() {\n        this.carousel.next(1);\n        this.carousel.stopAutoplay();\n    }\n\n    prev() {\n        this.carousel.prev(1);\n        this.carousel.stopAutoplay();\n    }\n\n    select(index: number) {\n        this.carousel.select(index);\n    }\n\n    isNextArrowDisabled() {\n        return this.carousel.isNextArrowDisabled();\n    }\n\n    isPrevArrowDisabled() {\n        return this.carousel.isPrevArrowDisabled();\n    }\n\n    getCellLength() {\n        if (this.images) {\n            return this.images.length;\n        } else {\n            return this.cellsElement.children.length;\n        }\n    }\n}","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CarouselComponent } from './carousel.component';\n\n@NgModule({\n    declarations: [\n        CarouselComponent\n    ],\n    imports: [\n        CommonModule\n    ],\n    exports: [\n        CarouselComponent\n    ],\n    providers: [\n\n    ],\n    bootstrap: [\n        \n    ],\n    entryComponents: [\n        CarouselComponent\n    ]\n})\nexport class IvyCarouselModule { }\n"]}